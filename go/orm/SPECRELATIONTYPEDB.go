// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/thomaspeugeot/gongreqif/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_SPECRELATIONTYPE_sql sql.NullBool
var dummy_SPECRELATIONTYPE_time time.Duration
var dummy_SPECRELATIONTYPE_sort sort.Float64Slice

// SPECRELATIONTYPEAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model specrelationtypeAPI
type SPECRELATIONTYPEAPI struct {
	gorm.Model

	models.SPECRELATIONTYPE_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	SPECRELATIONTYPEPointersEncoding SPECRELATIONTYPEPointersEncoding
}

// SPECRELATIONTYPEPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type SPECRELATIONTYPEPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field ALTERNATIVEID is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	ALTERNATIVEIDID sql.NullInt64

	// field SPECATTRIBUTES is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	SPECATTRIBUTESID sql.NullInt64
}

// SPECRELATIONTYPEDB describes a specrelationtype in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model specrelationtypeDB
type SPECRELATIONTYPEDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field specrelationtypeDB.Name
	Name_Data sql.NullString

	// Declation for basic field specrelationtypeDB.DESCAttr
	DESCAttr_Data sql.NullString

	// Declation for basic field specrelationtypeDB.IDENTIFIERAttr
	IDENTIFIERAttr_Data sql.NullString

	// Declation for basic field specrelationtypeDB.LASTCHANGEAttr
	LASTCHANGEAttr_Data sql.NullString

	// Declation for basic field specrelationtypeDB.LONGNAMEAttr
	LONGNAMEAttr_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	SPECRELATIONTYPEPointersEncoding
}

// SPECRELATIONTYPEDBs arrays specrelationtypeDBs
// swagger:response specrelationtypeDBsResponse
type SPECRELATIONTYPEDBs []SPECRELATIONTYPEDB

// SPECRELATIONTYPEDBResponse provides response
// swagger:response specrelationtypeDBResponse
type SPECRELATIONTYPEDBResponse struct {
	SPECRELATIONTYPEDB
}

// SPECRELATIONTYPEWOP is a SPECRELATIONTYPE without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type SPECRELATIONTYPEWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`

	DESCAttr string `xlsx:"2"`

	IDENTIFIERAttr string `xlsx:"3"`

	LASTCHANGEAttr string `xlsx:"4"`

	LONGNAMEAttr string `xlsx:"5"`
	// insertion for WOP pointer fields
}

var SPECRELATIONTYPE_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
	"DESCAttr",
	"IDENTIFIERAttr",
	"LASTCHANGEAttr",
	"LONGNAMEAttr",
}

type BackRepoSPECRELATIONTYPEStruct struct {
	// stores SPECRELATIONTYPEDB according to their gorm ID
	Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB map[uint]*SPECRELATIONTYPEDB

	// stores SPECRELATIONTYPEDB ID according to SPECRELATIONTYPE address
	Map_SPECRELATIONTYPEPtr_SPECRELATIONTYPEDBID map[*models.SPECRELATIONTYPE]uint

	// stores SPECRELATIONTYPE according to their gorm ID
	Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr map[uint]*models.SPECRELATIONTYPE

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoSPECRELATIONTYPE.stage
	return
}

func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) GetDB() *gorm.DB {
	return backRepoSPECRELATIONTYPE.db
}

// GetSPECRELATIONTYPEDBFromSPECRELATIONTYPEPtr is a handy function to access the back repo instance from the stage instance
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) GetSPECRELATIONTYPEDBFromSPECRELATIONTYPEPtr(specrelationtype *models.SPECRELATIONTYPE) (specrelationtypeDB *SPECRELATIONTYPEDB) {
	id := backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEPtr_SPECRELATIONTYPEDBID[specrelationtype]
	specrelationtypeDB = backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB[id]
	return
}

// BackRepoSPECRELATIONTYPE.CommitPhaseOne commits all staged instances of SPECRELATIONTYPE to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for specrelationtype := range stage.SPECRELATIONTYPEs {
		backRepoSPECRELATIONTYPE.CommitPhaseOneInstance(specrelationtype)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, specrelationtype := range backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr {
		if _, ok := stage.SPECRELATIONTYPEs[specrelationtype]; !ok {
			backRepoSPECRELATIONTYPE.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoSPECRELATIONTYPE.CommitDeleteInstance commits deletion of SPECRELATIONTYPE to the BackRepo
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) CommitDeleteInstance(id uint) (Error error) {

	specrelationtype := backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr[id]

	// specrelationtype is not staged anymore, remove specrelationtypeDB
	specrelationtypeDB := backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB[id]
	query := backRepoSPECRELATIONTYPE.db.Unscoped().Delete(&specrelationtypeDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEPtr_SPECRELATIONTYPEDBID, specrelationtype)
	delete(backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr, id)
	delete(backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB, id)

	return
}

// BackRepoSPECRELATIONTYPE.CommitPhaseOneInstance commits specrelationtype staged instances of SPECRELATIONTYPE to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) CommitPhaseOneInstance(specrelationtype *models.SPECRELATIONTYPE) (Error error) {

	// check if the specrelationtype is not commited yet
	if _, ok := backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEPtr_SPECRELATIONTYPEDBID[specrelationtype]; ok {
		return
	}

	// initiate specrelationtype
	var specrelationtypeDB SPECRELATIONTYPEDB
	specrelationtypeDB.CopyBasicFieldsFromSPECRELATIONTYPE(specrelationtype)

	query := backRepoSPECRELATIONTYPE.db.Create(&specrelationtypeDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEPtr_SPECRELATIONTYPEDBID[specrelationtype] = specrelationtypeDB.ID
	backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr[specrelationtypeDB.ID] = specrelationtype
	backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB[specrelationtypeDB.ID] = &specrelationtypeDB

	return
}

// BackRepoSPECRELATIONTYPE.CommitPhaseTwo commits all staged instances of SPECRELATIONTYPE to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, specrelationtype := range backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr {
		backRepoSPECRELATIONTYPE.CommitPhaseTwoInstance(backRepo, idx, specrelationtype)
	}

	return
}

// BackRepoSPECRELATIONTYPE.CommitPhaseTwoInstance commits {{structname }} of models.SPECRELATIONTYPE to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, specrelationtype *models.SPECRELATIONTYPE) (Error error) {

	// fetch matching specrelationtypeDB
	if specrelationtypeDB, ok := backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB[idx]; ok {

		specrelationtypeDB.CopyBasicFieldsFromSPECRELATIONTYPE(specrelationtype)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value specrelationtype.ALTERNATIVEID translates to updating the specrelationtype.ALTERNATIVEIDID
		specrelationtypeDB.ALTERNATIVEIDID.Valid = true // allow for a 0 value (nil association)
		if specrelationtype.ALTERNATIVEID != nil {
			if ALTERNATIVEIDId, ok := backRepo.BackRepoALTERNATIVEID.Map_ALTERNATIVEIDPtr_ALTERNATIVEIDDBID[specrelationtype.ALTERNATIVEID]; ok {
				specrelationtypeDB.ALTERNATIVEIDID.Int64 = int64(ALTERNATIVEIDId)
				specrelationtypeDB.ALTERNATIVEIDID.Valid = true
			}
		} else {
			specrelationtypeDB.ALTERNATIVEIDID.Int64 = 0
			specrelationtypeDB.ALTERNATIVEIDID.Valid = true
		}

		// commit pointer value specrelationtype.SPECATTRIBUTES translates to updating the specrelationtype.SPECATTRIBUTESID
		specrelationtypeDB.SPECATTRIBUTESID.Valid = true // allow for a 0 value (nil association)
		if specrelationtype.SPECATTRIBUTES != nil {
			if SPECATTRIBUTESId, ok := backRepo.BackRepoSPECATTRIBUTES.Map_SPECATTRIBUTESPtr_SPECATTRIBUTESDBID[specrelationtype.SPECATTRIBUTES]; ok {
				specrelationtypeDB.SPECATTRIBUTESID.Int64 = int64(SPECATTRIBUTESId)
				specrelationtypeDB.SPECATTRIBUTESID.Valid = true
			}
		} else {
			specrelationtypeDB.SPECATTRIBUTESID.Int64 = 0
			specrelationtypeDB.SPECATTRIBUTESID.Valid = true
		}

		query := backRepoSPECRELATIONTYPE.db.Save(&specrelationtypeDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown SPECRELATIONTYPE intance %s", specrelationtype.Name))
		return err
	}

	return
}

// BackRepoSPECRELATIONTYPE.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) CheckoutPhaseOne() (Error error) {

	specrelationtypeDBArray := make([]SPECRELATIONTYPEDB, 0)
	query := backRepoSPECRELATIONTYPE.db.Find(&specrelationtypeDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	specrelationtypeInstancesToBeRemovedFromTheStage := make(map[*models.SPECRELATIONTYPE]any)
	for key, value := range backRepoSPECRELATIONTYPE.stage.SPECRELATIONTYPEs {
		specrelationtypeInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, specrelationtypeDB := range specrelationtypeDBArray {
		backRepoSPECRELATIONTYPE.CheckoutPhaseOneInstance(&specrelationtypeDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		specrelationtype, ok := backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr[specrelationtypeDB.ID]
		if ok {
			delete(specrelationtypeInstancesToBeRemovedFromTheStage, specrelationtype)
		}
	}

	// remove from stage and back repo's 3 maps all specrelationtypes that are not in the checkout
	for specrelationtype := range specrelationtypeInstancesToBeRemovedFromTheStage {
		specrelationtype.Unstage(backRepoSPECRELATIONTYPE.GetStage())

		// remove instance from the back repo 3 maps
		specrelationtypeID := backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEPtr_SPECRELATIONTYPEDBID[specrelationtype]
		delete(backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEPtr_SPECRELATIONTYPEDBID, specrelationtype)
		delete(backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB, specrelationtypeID)
		delete(backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr, specrelationtypeID)
	}

	return
}

// CheckoutPhaseOneInstance takes a specrelationtypeDB that has been found in the DB, updates the backRepo and stages the
// models version of the specrelationtypeDB
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) CheckoutPhaseOneInstance(specrelationtypeDB *SPECRELATIONTYPEDB) (Error error) {

	specrelationtype, ok := backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr[specrelationtypeDB.ID]
	if !ok {
		specrelationtype = new(models.SPECRELATIONTYPE)

		backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr[specrelationtypeDB.ID] = specrelationtype
		backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEPtr_SPECRELATIONTYPEDBID[specrelationtype] = specrelationtypeDB.ID

		// append model store with the new element
		specrelationtype.Name = specrelationtypeDB.Name_Data.String
		specrelationtype.Stage(backRepoSPECRELATIONTYPE.GetStage())
	}
	specrelationtypeDB.CopyBasicFieldsToSPECRELATIONTYPE(specrelationtype)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	specrelationtype.Stage(backRepoSPECRELATIONTYPE.GetStage())

	// preserve pointer to specrelationtypeDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB)[specrelationtypeDB hold variable pointers
	specrelationtypeDB_Data := *specrelationtypeDB
	preservedPtrToSPECRELATIONTYPE := &specrelationtypeDB_Data
	backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB[specrelationtypeDB.ID] = preservedPtrToSPECRELATIONTYPE

	return
}

// BackRepoSPECRELATIONTYPE.CheckoutPhaseTwo Checkouts all staged instances of SPECRELATIONTYPE to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, specrelationtypeDB := range backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB {
		backRepoSPECRELATIONTYPE.CheckoutPhaseTwoInstance(backRepo, specrelationtypeDB)
	}
	return
}

// BackRepoSPECRELATIONTYPE.CheckoutPhaseTwoInstance Checkouts staged instances of SPECRELATIONTYPE to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, specrelationtypeDB *SPECRELATIONTYPEDB) (Error error) {

	specrelationtype := backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr[specrelationtypeDB.ID]

	specrelationtypeDB.DecodePointers(backRepo, specrelationtype)

	return
}

func (specrelationtypeDB *SPECRELATIONTYPEDB) DecodePointers(backRepo *BackRepoStruct, specrelationtype *models.SPECRELATIONTYPE) {

	// insertion point for checkout of pointer encoding
	// ALTERNATIVEID field
	specrelationtype.ALTERNATIVEID = nil
	if specrelationtypeDB.ALTERNATIVEIDID.Int64 != 0 {
		specrelationtype.ALTERNATIVEID = backRepo.BackRepoALTERNATIVEID.Map_ALTERNATIVEIDDBID_ALTERNATIVEIDPtr[uint(specrelationtypeDB.ALTERNATIVEIDID.Int64)]
	}
	// SPECATTRIBUTES field
	specrelationtype.SPECATTRIBUTES = nil
	if specrelationtypeDB.SPECATTRIBUTESID.Int64 != 0 {
		specrelationtype.SPECATTRIBUTES = backRepo.BackRepoSPECATTRIBUTES.Map_SPECATTRIBUTESDBID_SPECATTRIBUTESPtr[uint(specrelationtypeDB.SPECATTRIBUTESID.Int64)]
	}
	return
}

// CommitSPECRELATIONTYPE allows commit of a single specrelationtype (if already staged)
func (backRepo *BackRepoStruct) CommitSPECRELATIONTYPE(specrelationtype *models.SPECRELATIONTYPE) {
	backRepo.BackRepoSPECRELATIONTYPE.CommitPhaseOneInstance(specrelationtype)
	if id, ok := backRepo.BackRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEPtr_SPECRELATIONTYPEDBID[specrelationtype]; ok {
		backRepo.BackRepoSPECRELATIONTYPE.CommitPhaseTwoInstance(backRepo, id, specrelationtype)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitSPECRELATIONTYPE allows checkout of a single specrelationtype (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutSPECRELATIONTYPE(specrelationtype *models.SPECRELATIONTYPE) {
	// check if the specrelationtype is staged
	if _, ok := backRepo.BackRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEPtr_SPECRELATIONTYPEDBID[specrelationtype]; ok {

		if id, ok := backRepo.BackRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEPtr_SPECRELATIONTYPEDBID[specrelationtype]; ok {
			var specrelationtypeDB SPECRELATIONTYPEDB
			specrelationtypeDB.ID = id

			if err := backRepo.BackRepoSPECRELATIONTYPE.db.First(&specrelationtypeDB, id).Error; err != nil {
				log.Fatalln("CheckoutSPECRELATIONTYPE : Problem with getting object with id:", id)
			}
			backRepo.BackRepoSPECRELATIONTYPE.CheckoutPhaseOneInstance(&specrelationtypeDB)
			backRepo.BackRepoSPECRELATIONTYPE.CheckoutPhaseTwoInstance(backRepo, &specrelationtypeDB)
		}
	}
}

// CopyBasicFieldsFromSPECRELATIONTYPE
func (specrelationtypeDB *SPECRELATIONTYPEDB) CopyBasicFieldsFromSPECRELATIONTYPE(specrelationtype *models.SPECRELATIONTYPE) {
	// insertion point for fields commit

	specrelationtypeDB.Name_Data.String = specrelationtype.Name
	specrelationtypeDB.Name_Data.Valid = true

	specrelationtypeDB.DESCAttr_Data.String = specrelationtype.DESCAttr
	specrelationtypeDB.DESCAttr_Data.Valid = true

	specrelationtypeDB.IDENTIFIERAttr_Data.String = specrelationtype.IDENTIFIERAttr
	specrelationtypeDB.IDENTIFIERAttr_Data.Valid = true

	specrelationtypeDB.LASTCHANGEAttr_Data.String = specrelationtype.LASTCHANGEAttr
	specrelationtypeDB.LASTCHANGEAttr_Data.Valid = true

	specrelationtypeDB.LONGNAMEAttr_Data.String = specrelationtype.LONGNAMEAttr
	specrelationtypeDB.LONGNAMEAttr_Data.Valid = true
}

// CopyBasicFieldsFromSPECRELATIONTYPE_WOP
func (specrelationtypeDB *SPECRELATIONTYPEDB) CopyBasicFieldsFromSPECRELATIONTYPE_WOP(specrelationtype *models.SPECRELATIONTYPE_WOP) {
	// insertion point for fields commit

	specrelationtypeDB.Name_Data.String = specrelationtype.Name
	specrelationtypeDB.Name_Data.Valid = true

	specrelationtypeDB.DESCAttr_Data.String = specrelationtype.DESCAttr
	specrelationtypeDB.DESCAttr_Data.Valid = true

	specrelationtypeDB.IDENTIFIERAttr_Data.String = specrelationtype.IDENTIFIERAttr
	specrelationtypeDB.IDENTIFIERAttr_Data.Valid = true

	specrelationtypeDB.LASTCHANGEAttr_Data.String = specrelationtype.LASTCHANGEAttr
	specrelationtypeDB.LASTCHANGEAttr_Data.Valid = true

	specrelationtypeDB.LONGNAMEAttr_Data.String = specrelationtype.LONGNAMEAttr
	specrelationtypeDB.LONGNAMEAttr_Data.Valid = true
}

// CopyBasicFieldsFromSPECRELATIONTYPEWOP
func (specrelationtypeDB *SPECRELATIONTYPEDB) CopyBasicFieldsFromSPECRELATIONTYPEWOP(specrelationtype *SPECRELATIONTYPEWOP) {
	// insertion point for fields commit

	specrelationtypeDB.Name_Data.String = specrelationtype.Name
	specrelationtypeDB.Name_Data.Valid = true

	specrelationtypeDB.DESCAttr_Data.String = specrelationtype.DESCAttr
	specrelationtypeDB.DESCAttr_Data.Valid = true

	specrelationtypeDB.IDENTIFIERAttr_Data.String = specrelationtype.IDENTIFIERAttr
	specrelationtypeDB.IDENTIFIERAttr_Data.Valid = true

	specrelationtypeDB.LASTCHANGEAttr_Data.String = specrelationtype.LASTCHANGEAttr
	specrelationtypeDB.LASTCHANGEAttr_Data.Valid = true

	specrelationtypeDB.LONGNAMEAttr_Data.String = specrelationtype.LONGNAMEAttr
	specrelationtypeDB.LONGNAMEAttr_Data.Valid = true
}

// CopyBasicFieldsToSPECRELATIONTYPE
func (specrelationtypeDB *SPECRELATIONTYPEDB) CopyBasicFieldsToSPECRELATIONTYPE(specrelationtype *models.SPECRELATIONTYPE) {
	// insertion point for checkout of basic fields (back repo to stage)
	specrelationtype.Name = specrelationtypeDB.Name_Data.String
	specrelationtype.DESCAttr = specrelationtypeDB.DESCAttr_Data.String
	specrelationtype.IDENTIFIERAttr = specrelationtypeDB.IDENTIFIERAttr_Data.String
	specrelationtype.LASTCHANGEAttr = specrelationtypeDB.LASTCHANGEAttr_Data.String
	specrelationtype.LONGNAMEAttr = specrelationtypeDB.LONGNAMEAttr_Data.String
}

// CopyBasicFieldsToSPECRELATIONTYPE_WOP
func (specrelationtypeDB *SPECRELATIONTYPEDB) CopyBasicFieldsToSPECRELATIONTYPE_WOP(specrelationtype *models.SPECRELATIONTYPE_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	specrelationtype.Name = specrelationtypeDB.Name_Data.String
	specrelationtype.DESCAttr = specrelationtypeDB.DESCAttr_Data.String
	specrelationtype.IDENTIFIERAttr = specrelationtypeDB.IDENTIFIERAttr_Data.String
	specrelationtype.LASTCHANGEAttr = specrelationtypeDB.LASTCHANGEAttr_Data.String
	specrelationtype.LONGNAMEAttr = specrelationtypeDB.LONGNAMEAttr_Data.String
}

// CopyBasicFieldsToSPECRELATIONTYPEWOP
func (specrelationtypeDB *SPECRELATIONTYPEDB) CopyBasicFieldsToSPECRELATIONTYPEWOP(specrelationtype *SPECRELATIONTYPEWOP) {
	specrelationtype.ID = int(specrelationtypeDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	specrelationtype.Name = specrelationtypeDB.Name_Data.String
	specrelationtype.DESCAttr = specrelationtypeDB.DESCAttr_Data.String
	specrelationtype.IDENTIFIERAttr = specrelationtypeDB.IDENTIFIERAttr_Data.String
	specrelationtype.LASTCHANGEAttr = specrelationtypeDB.LASTCHANGEAttr_Data.String
	specrelationtype.LONGNAMEAttr = specrelationtypeDB.LONGNAMEAttr_Data.String
}

// Backup generates a json file from a slice of all SPECRELATIONTYPEDB instances in the backrepo
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "SPECRELATIONTYPEDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*SPECRELATIONTYPEDB, 0)
	for _, specrelationtypeDB := range backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB {
		forBackup = append(forBackup, specrelationtypeDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json SPECRELATIONTYPE ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json SPECRELATIONTYPE file", err.Error())
	}
}

// Backup generates a json file from a slice of all SPECRELATIONTYPEDB instances in the backrepo
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*SPECRELATIONTYPEDB, 0)
	for _, specrelationtypeDB := range backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB {
		forBackup = append(forBackup, specrelationtypeDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("SPECRELATIONTYPE")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&SPECRELATIONTYPE_Fields, -1)
	for _, specrelationtypeDB := range forBackup {

		var specrelationtypeWOP SPECRELATIONTYPEWOP
		specrelationtypeDB.CopyBasicFieldsToSPECRELATIONTYPEWOP(&specrelationtypeWOP)

		row := sh.AddRow()
		row.WriteStruct(&specrelationtypeWOP, -1)
	}
}

// RestoreXL from the "SPECRELATIONTYPE" sheet all SPECRELATIONTYPEDB instances
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoSPECRELATIONTYPEid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["SPECRELATIONTYPE"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoSPECRELATIONTYPE.rowVisitorSPECRELATIONTYPE)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) rowVisitorSPECRELATIONTYPE(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var specrelationtypeWOP SPECRELATIONTYPEWOP
		row.ReadStruct(&specrelationtypeWOP)

		// add the unmarshalled struct to the stage
		specrelationtypeDB := new(SPECRELATIONTYPEDB)
		specrelationtypeDB.CopyBasicFieldsFromSPECRELATIONTYPEWOP(&specrelationtypeWOP)

		specrelationtypeDB_ID_atBackupTime := specrelationtypeDB.ID
		specrelationtypeDB.ID = 0
		query := backRepoSPECRELATIONTYPE.db.Create(specrelationtypeDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB[specrelationtypeDB.ID] = specrelationtypeDB
		BackRepoSPECRELATIONTYPEid_atBckpTime_newID[specrelationtypeDB_ID_atBackupTime] = specrelationtypeDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "SPECRELATIONTYPEDB.json" in dirPath that stores an array
// of SPECRELATIONTYPEDB and stores it in the database
// the map BackRepoSPECRELATIONTYPEid_atBckpTime_newID is updated accordingly
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoSPECRELATIONTYPEid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "SPECRELATIONTYPEDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json SPECRELATIONTYPE file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*SPECRELATIONTYPEDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB
	for _, specrelationtypeDB := range forRestore {

		specrelationtypeDB_ID_atBackupTime := specrelationtypeDB.ID
		specrelationtypeDB.ID = 0
		query := backRepoSPECRELATIONTYPE.db.Create(specrelationtypeDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB[specrelationtypeDB.ID] = specrelationtypeDB
		BackRepoSPECRELATIONTYPEid_atBckpTime_newID[specrelationtypeDB_ID_atBackupTime] = specrelationtypeDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json SPECRELATIONTYPE file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<SPECRELATIONTYPE>id_atBckpTime_newID
// to compute new index
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) RestorePhaseTwo() {

	for _, specrelationtypeDB := range backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB {

		// next line of code is to avert unused variable compilation error
		_ = specrelationtypeDB

		// insertion point for reindexing pointers encoding
		// reindexing ALTERNATIVEID field
		if specrelationtypeDB.ALTERNATIVEIDID.Int64 != 0 {
			specrelationtypeDB.ALTERNATIVEIDID.Int64 = int64(BackRepoALTERNATIVEIDid_atBckpTime_newID[uint(specrelationtypeDB.ALTERNATIVEIDID.Int64)])
			specrelationtypeDB.ALTERNATIVEIDID.Valid = true
		}

		// reindexing SPECATTRIBUTES field
		if specrelationtypeDB.SPECATTRIBUTESID.Int64 != 0 {
			specrelationtypeDB.SPECATTRIBUTESID.Int64 = int64(BackRepoSPECATTRIBUTESid_atBckpTime_newID[uint(specrelationtypeDB.SPECATTRIBUTESID.Int64)])
			specrelationtypeDB.SPECATTRIBUTESID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoSPECRELATIONTYPE.db.Model(specrelationtypeDB).Updates(*specrelationtypeDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoSPECRELATIONTYPE.ResetReversePointers commits all staged instances of SPECRELATIONTYPE to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, specrelationtype := range backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEPtr {
		backRepoSPECRELATIONTYPE.ResetReversePointersInstance(backRepo, idx, specrelationtype)
	}

	return
}

func (backRepoSPECRELATIONTYPE *BackRepoSPECRELATIONTYPEStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, specrelationtype *models.SPECRELATIONTYPE) (Error error) {

	// fetch matching specrelationtypeDB
	if specrelationtypeDB, ok := backRepoSPECRELATIONTYPE.Map_SPECRELATIONTYPEDBID_SPECRELATIONTYPEDB[idx]; ok {
		_ = specrelationtypeDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoSPECRELATIONTYPEid_atBckpTime_newID map[uint]uint
