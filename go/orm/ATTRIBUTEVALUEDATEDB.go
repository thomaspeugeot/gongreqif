// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/thomaspeugeot/gongreqif/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_ATTRIBUTEVALUEDATE_sql sql.NullBool
var dummy_ATTRIBUTEVALUEDATE_time time.Duration
var dummy_ATTRIBUTEVALUEDATE_sort sort.Float64Slice

// ATTRIBUTEVALUEDATEAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model attributevaluedateAPI
type ATTRIBUTEVALUEDATEAPI struct {
	gorm.Model

	models.ATTRIBUTEVALUEDATE_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	ATTRIBUTEVALUEDATEPointersEncoding ATTRIBUTEVALUEDATEPointersEncoding
}

// ATTRIBUTEVALUEDATEPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type ATTRIBUTEVALUEDATEPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field DEFINITION is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	DEFINITIONID sql.NullInt64
}

// ATTRIBUTEVALUEDATEDB describes a attributevaluedate in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model attributevaluedateDB
type ATTRIBUTEVALUEDATEDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field attributevaluedateDB.Name
	Name_Data sql.NullString

	// Declation for basic field attributevaluedateDB.THEVALUEAttr
	THEVALUEAttr_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	ATTRIBUTEVALUEDATEPointersEncoding
}

// ATTRIBUTEVALUEDATEDBs arrays attributevaluedateDBs
// swagger:response attributevaluedateDBsResponse
type ATTRIBUTEVALUEDATEDBs []ATTRIBUTEVALUEDATEDB

// ATTRIBUTEVALUEDATEDBResponse provides response
// swagger:response attributevaluedateDBResponse
type ATTRIBUTEVALUEDATEDBResponse struct {
	ATTRIBUTEVALUEDATEDB
}

// ATTRIBUTEVALUEDATEWOP is a ATTRIBUTEVALUEDATE without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type ATTRIBUTEVALUEDATEWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`

	THEVALUEAttr string `xlsx:"2"`
	// insertion for WOP pointer fields
}

var ATTRIBUTEVALUEDATE_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
	"THEVALUEAttr",
}

type BackRepoATTRIBUTEVALUEDATEStruct struct {
	// stores ATTRIBUTEVALUEDATEDB according to their gorm ID
	Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB map[uint]*ATTRIBUTEVALUEDATEDB

	// stores ATTRIBUTEVALUEDATEDB ID according to ATTRIBUTEVALUEDATE address
	Map_ATTRIBUTEVALUEDATEPtr_ATTRIBUTEVALUEDATEDBID map[*models.ATTRIBUTEVALUEDATE]uint

	// stores ATTRIBUTEVALUEDATE according to their gorm ID
	Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr map[uint]*models.ATTRIBUTEVALUEDATE

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoATTRIBUTEVALUEDATE.stage
	return
}

func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) GetDB() *gorm.DB {
	return backRepoATTRIBUTEVALUEDATE.db
}

// GetATTRIBUTEVALUEDATEDBFromATTRIBUTEVALUEDATEPtr is a handy function to access the back repo instance from the stage instance
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) GetATTRIBUTEVALUEDATEDBFromATTRIBUTEVALUEDATEPtr(attributevaluedate *models.ATTRIBUTEVALUEDATE) (attributevaluedateDB *ATTRIBUTEVALUEDATEDB) {
	id := backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEPtr_ATTRIBUTEVALUEDATEDBID[attributevaluedate]
	attributevaluedateDB = backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB[id]
	return
}

// BackRepoATTRIBUTEVALUEDATE.CommitPhaseOne commits all staged instances of ATTRIBUTEVALUEDATE to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for attributevaluedate := range stage.ATTRIBUTEVALUEDATEs {
		backRepoATTRIBUTEVALUEDATE.CommitPhaseOneInstance(attributevaluedate)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, attributevaluedate := range backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr {
		if _, ok := stage.ATTRIBUTEVALUEDATEs[attributevaluedate]; !ok {
			backRepoATTRIBUTEVALUEDATE.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoATTRIBUTEVALUEDATE.CommitDeleteInstance commits deletion of ATTRIBUTEVALUEDATE to the BackRepo
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) CommitDeleteInstance(id uint) (Error error) {

	attributevaluedate := backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr[id]

	// attributevaluedate is not staged anymore, remove attributevaluedateDB
	attributevaluedateDB := backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB[id]
	query := backRepoATTRIBUTEVALUEDATE.db.Unscoped().Delete(&attributevaluedateDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEPtr_ATTRIBUTEVALUEDATEDBID, attributevaluedate)
	delete(backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr, id)
	delete(backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB, id)

	return
}

// BackRepoATTRIBUTEVALUEDATE.CommitPhaseOneInstance commits attributevaluedate staged instances of ATTRIBUTEVALUEDATE to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) CommitPhaseOneInstance(attributevaluedate *models.ATTRIBUTEVALUEDATE) (Error error) {

	// check if the attributevaluedate is not commited yet
	if _, ok := backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEPtr_ATTRIBUTEVALUEDATEDBID[attributevaluedate]; ok {
		return
	}

	// initiate attributevaluedate
	var attributevaluedateDB ATTRIBUTEVALUEDATEDB
	attributevaluedateDB.CopyBasicFieldsFromATTRIBUTEVALUEDATE(attributevaluedate)

	query := backRepoATTRIBUTEVALUEDATE.db.Create(&attributevaluedateDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEPtr_ATTRIBUTEVALUEDATEDBID[attributevaluedate] = attributevaluedateDB.ID
	backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr[attributevaluedateDB.ID] = attributevaluedate
	backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB[attributevaluedateDB.ID] = &attributevaluedateDB

	return
}

// BackRepoATTRIBUTEVALUEDATE.CommitPhaseTwo commits all staged instances of ATTRIBUTEVALUEDATE to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, attributevaluedate := range backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr {
		backRepoATTRIBUTEVALUEDATE.CommitPhaseTwoInstance(backRepo, idx, attributevaluedate)
	}

	return
}

// BackRepoATTRIBUTEVALUEDATE.CommitPhaseTwoInstance commits {{structname }} of models.ATTRIBUTEVALUEDATE to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, attributevaluedate *models.ATTRIBUTEVALUEDATE) (Error error) {

	// fetch matching attributevaluedateDB
	if attributevaluedateDB, ok := backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB[idx]; ok {

		attributevaluedateDB.CopyBasicFieldsFromATTRIBUTEVALUEDATE(attributevaluedate)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value attributevaluedate.DEFINITION translates to updating the attributevaluedate.DEFINITIONID
		attributevaluedateDB.DEFINITIONID.Valid = true // allow for a 0 value (nil association)
		if attributevaluedate.DEFINITION != nil {
			if DEFINITIONId, ok := backRepo.BackRepoDEFINITION.Map_DEFINITIONPtr_DEFINITIONDBID[attributevaluedate.DEFINITION]; ok {
				attributevaluedateDB.DEFINITIONID.Int64 = int64(DEFINITIONId)
				attributevaluedateDB.DEFINITIONID.Valid = true
			}
		} else {
			attributevaluedateDB.DEFINITIONID.Int64 = 0
			attributevaluedateDB.DEFINITIONID.Valid = true
		}

		query := backRepoATTRIBUTEVALUEDATE.db.Save(&attributevaluedateDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown ATTRIBUTEVALUEDATE intance %s", attributevaluedate.Name))
		return err
	}

	return
}

// BackRepoATTRIBUTEVALUEDATE.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) CheckoutPhaseOne() (Error error) {

	attributevaluedateDBArray := make([]ATTRIBUTEVALUEDATEDB, 0)
	query := backRepoATTRIBUTEVALUEDATE.db.Find(&attributevaluedateDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	attributevaluedateInstancesToBeRemovedFromTheStage := make(map[*models.ATTRIBUTEVALUEDATE]any)
	for key, value := range backRepoATTRIBUTEVALUEDATE.stage.ATTRIBUTEVALUEDATEs {
		attributevaluedateInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, attributevaluedateDB := range attributevaluedateDBArray {
		backRepoATTRIBUTEVALUEDATE.CheckoutPhaseOneInstance(&attributevaluedateDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		attributevaluedate, ok := backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr[attributevaluedateDB.ID]
		if ok {
			delete(attributevaluedateInstancesToBeRemovedFromTheStage, attributevaluedate)
		}
	}

	// remove from stage and back repo's 3 maps all attributevaluedates that are not in the checkout
	for attributevaluedate := range attributevaluedateInstancesToBeRemovedFromTheStage {
		attributevaluedate.Unstage(backRepoATTRIBUTEVALUEDATE.GetStage())

		// remove instance from the back repo 3 maps
		attributevaluedateID := backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEPtr_ATTRIBUTEVALUEDATEDBID[attributevaluedate]
		delete(backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEPtr_ATTRIBUTEVALUEDATEDBID, attributevaluedate)
		delete(backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB, attributevaluedateID)
		delete(backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr, attributevaluedateID)
	}

	return
}

// CheckoutPhaseOneInstance takes a attributevaluedateDB that has been found in the DB, updates the backRepo and stages the
// models version of the attributevaluedateDB
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) CheckoutPhaseOneInstance(attributevaluedateDB *ATTRIBUTEVALUEDATEDB) (Error error) {

	attributevaluedate, ok := backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr[attributevaluedateDB.ID]
	if !ok {
		attributevaluedate = new(models.ATTRIBUTEVALUEDATE)

		backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr[attributevaluedateDB.ID] = attributevaluedate
		backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEPtr_ATTRIBUTEVALUEDATEDBID[attributevaluedate] = attributevaluedateDB.ID

		// append model store with the new element
		attributevaluedate.Name = attributevaluedateDB.Name_Data.String
		attributevaluedate.Stage(backRepoATTRIBUTEVALUEDATE.GetStage())
	}
	attributevaluedateDB.CopyBasicFieldsToATTRIBUTEVALUEDATE(attributevaluedate)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	attributevaluedate.Stage(backRepoATTRIBUTEVALUEDATE.GetStage())

	// preserve pointer to attributevaluedateDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB)[attributevaluedateDB hold variable pointers
	attributevaluedateDB_Data := *attributevaluedateDB
	preservedPtrToATTRIBUTEVALUEDATE := &attributevaluedateDB_Data
	backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB[attributevaluedateDB.ID] = preservedPtrToATTRIBUTEVALUEDATE

	return
}

// BackRepoATTRIBUTEVALUEDATE.CheckoutPhaseTwo Checkouts all staged instances of ATTRIBUTEVALUEDATE to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, attributevaluedateDB := range backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB {
		backRepoATTRIBUTEVALUEDATE.CheckoutPhaseTwoInstance(backRepo, attributevaluedateDB)
	}
	return
}

// BackRepoATTRIBUTEVALUEDATE.CheckoutPhaseTwoInstance Checkouts staged instances of ATTRIBUTEVALUEDATE to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, attributevaluedateDB *ATTRIBUTEVALUEDATEDB) (Error error) {

	attributevaluedate := backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr[attributevaluedateDB.ID]

	attributevaluedateDB.DecodePointers(backRepo, attributevaluedate)

	return
}

func (attributevaluedateDB *ATTRIBUTEVALUEDATEDB) DecodePointers(backRepo *BackRepoStruct, attributevaluedate *models.ATTRIBUTEVALUEDATE) {

	// insertion point for checkout of pointer encoding
	// DEFINITION field
	attributevaluedate.DEFINITION = nil
	if attributevaluedateDB.DEFINITIONID.Int64 != 0 {
		attributevaluedate.DEFINITION = backRepo.BackRepoDEFINITION.Map_DEFINITIONDBID_DEFINITIONPtr[uint(attributevaluedateDB.DEFINITIONID.Int64)]
	}
	return
}

// CommitATTRIBUTEVALUEDATE allows commit of a single attributevaluedate (if already staged)
func (backRepo *BackRepoStruct) CommitATTRIBUTEVALUEDATE(attributevaluedate *models.ATTRIBUTEVALUEDATE) {
	backRepo.BackRepoATTRIBUTEVALUEDATE.CommitPhaseOneInstance(attributevaluedate)
	if id, ok := backRepo.BackRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEPtr_ATTRIBUTEVALUEDATEDBID[attributevaluedate]; ok {
		backRepo.BackRepoATTRIBUTEVALUEDATE.CommitPhaseTwoInstance(backRepo, id, attributevaluedate)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitATTRIBUTEVALUEDATE allows checkout of a single attributevaluedate (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutATTRIBUTEVALUEDATE(attributevaluedate *models.ATTRIBUTEVALUEDATE) {
	// check if the attributevaluedate is staged
	if _, ok := backRepo.BackRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEPtr_ATTRIBUTEVALUEDATEDBID[attributevaluedate]; ok {

		if id, ok := backRepo.BackRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEPtr_ATTRIBUTEVALUEDATEDBID[attributevaluedate]; ok {
			var attributevaluedateDB ATTRIBUTEVALUEDATEDB
			attributevaluedateDB.ID = id

			if err := backRepo.BackRepoATTRIBUTEVALUEDATE.db.First(&attributevaluedateDB, id).Error; err != nil {
				log.Fatalln("CheckoutATTRIBUTEVALUEDATE : Problem with getting object with id:", id)
			}
			backRepo.BackRepoATTRIBUTEVALUEDATE.CheckoutPhaseOneInstance(&attributevaluedateDB)
			backRepo.BackRepoATTRIBUTEVALUEDATE.CheckoutPhaseTwoInstance(backRepo, &attributevaluedateDB)
		}
	}
}

// CopyBasicFieldsFromATTRIBUTEVALUEDATE
func (attributevaluedateDB *ATTRIBUTEVALUEDATEDB) CopyBasicFieldsFromATTRIBUTEVALUEDATE(attributevaluedate *models.ATTRIBUTEVALUEDATE) {
	// insertion point for fields commit

	attributevaluedateDB.Name_Data.String = attributevaluedate.Name
	attributevaluedateDB.Name_Data.Valid = true

	attributevaluedateDB.THEVALUEAttr_Data.String = attributevaluedate.THEVALUEAttr
	attributevaluedateDB.THEVALUEAttr_Data.Valid = true
}

// CopyBasicFieldsFromATTRIBUTEVALUEDATE_WOP
func (attributevaluedateDB *ATTRIBUTEVALUEDATEDB) CopyBasicFieldsFromATTRIBUTEVALUEDATE_WOP(attributevaluedate *models.ATTRIBUTEVALUEDATE_WOP) {
	// insertion point for fields commit

	attributevaluedateDB.Name_Data.String = attributevaluedate.Name
	attributevaluedateDB.Name_Data.Valid = true

	attributevaluedateDB.THEVALUEAttr_Data.String = attributevaluedate.THEVALUEAttr
	attributevaluedateDB.THEVALUEAttr_Data.Valid = true
}

// CopyBasicFieldsFromATTRIBUTEVALUEDATEWOP
func (attributevaluedateDB *ATTRIBUTEVALUEDATEDB) CopyBasicFieldsFromATTRIBUTEVALUEDATEWOP(attributevaluedate *ATTRIBUTEVALUEDATEWOP) {
	// insertion point for fields commit

	attributevaluedateDB.Name_Data.String = attributevaluedate.Name
	attributevaluedateDB.Name_Data.Valid = true

	attributevaluedateDB.THEVALUEAttr_Data.String = attributevaluedate.THEVALUEAttr
	attributevaluedateDB.THEVALUEAttr_Data.Valid = true
}

// CopyBasicFieldsToATTRIBUTEVALUEDATE
func (attributevaluedateDB *ATTRIBUTEVALUEDATEDB) CopyBasicFieldsToATTRIBUTEVALUEDATE(attributevaluedate *models.ATTRIBUTEVALUEDATE) {
	// insertion point for checkout of basic fields (back repo to stage)
	attributevaluedate.Name = attributevaluedateDB.Name_Data.String
	attributevaluedate.THEVALUEAttr = attributevaluedateDB.THEVALUEAttr_Data.String
}

// CopyBasicFieldsToATTRIBUTEVALUEDATE_WOP
func (attributevaluedateDB *ATTRIBUTEVALUEDATEDB) CopyBasicFieldsToATTRIBUTEVALUEDATE_WOP(attributevaluedate *models.ATTRIBUTEVALUEDATE_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	attributevaluedate.Name = attributevaluedateDB.Name_Data.String
	attributevaluedate.THEVALUEAttr = attributevaluedateDB.THEVALUEAttr_Data.String
}

// CopyBasicFieldsToATTRIBUTEVALUEDATEWOP
func (attributevaluedateDB *ATTRIBUTEVALUEDATEDB) CopyBasicFieldsToATTRIBUTEVALUEDATEWOP(attributevaluedate *ATTRIBUTEVALUEDATEWOP) {
	attributevaluedate.ID = int(attributevaluedateDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	attributevaluedate.Name = attributevaluedateDB.Name_Data.String
	attributevaluedate.THEVALUEAttr = attributevaluedateDB.THEVALUEAttr_Data.String
}

// Backup generates a json file from a slice of all ATTRIBUTEVALUEDATEDB instances in the backrepo
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "ATTRIBUTEVALUEDATEDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*ATTRIBUTEVALUEDATEDB, 0)
	for _, attributevaluedateDB := range backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB {
		forBackup = append(forBackup, attributevaluedateDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json ATTRIBUTEVALUEDATE ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json ATTRIBUTEVALUEDATE file", err.Error())
	}
}

// Backup generates a json file from a slice of all ATTRIBUTEVALUEDATEDB instances in the backrepo
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*ATTRIBUTEVALUEDATEDB, 0)
	for _, attributevaluedateDB := range backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB {
		forBackup = append(forBackup, attributevaluedateDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("ATTRIBUTEVALUEDATE")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&ATTRIBUTEVALUEDATE_Fields, -1)
	for _, attributevaluedateDB := range forBackup {

		var attributevaluedateWOP ATTRIBUTEVALUEDATEWOP
		attributevaluedateDB.CopyBasicFieldsToATTRIBUTEVALUEDATEWOP(&attributevaluedateWOP)

		row := sh.AddRow()
		row.WriteStruct(&attributevaluedateWOP, -1)
	}
}

// RestoreXL from the "ATTRIBUTEVALUEDATE" sheet all ATTRIBUTEVALUEDATEDB instances
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoATTRIBUTEVALUEDATEid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["ATTRIBUTEVALUEDATE"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoATTRIBUTEVALUEDATE.rowVisitorATTRIBUTEVALUEDATE)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) rowVisitorATTRIBUTEVALUEDATE(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var attributevaluedateWOP ATTRIBUTEVALUEDATEWOP
		row.ReadStruct(&attributevaluedateWOP)

		// add the unmarshalled struct to the stage
		attributevaluedateDB := new(ATTRIBUTEVALUEDATEDB)
		attributevaluedateDB.CopyBasicFieldsFromATTRIBUTEVALUEDATEWOP(&attributevaluedateWOP)

		attributevaluedateDB_ID_atBackupTime := attributevaluedateDB.ID
		attributevaluedateDB.ID = 0
		query := backRepoATTRIBUTEVALUEDATE.db.Create(attributevaluedateDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB[attributevaluedateDB.ID] = attributevaluedateDB
		BackRepoATTRIBUTEVALUEDATEid_atBckpTime_newID[attributevaluedateDB_ID_atBackupTime] = attributevaluedateDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "ATTRIBUTEVALUEDATEDB.json" in dirPath that stores an array
// of ATTRIBUTEVALUEDATEDB and stores it in the database
// the map BackRepoATTRIBUTEVALUEDATEid_atBckpTime_newID is updated accordingly
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoATTRIBUTEVALUEDATEid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "ATTRIBUTEVALUEDATEDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json ATTRIBUTEVALUEDATE file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*ATTRIBUTEVALUEDATEDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB
	for _, attributevaluedateDB := range forRestore {

		attributevaluedateDB_ID_atBackupTime := attributevaluedateDB.ID
		attributevaluedateDB.ID = 0
		query := backRepoATTRIBUTEVALUEDATE.db.Create(attributevaluedateDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB[attributevaluedateDB.ID] = attributevaluedateDB
		BackRepoATTRIBUTEVALUEDATEid_atBckpTime_newID[attributevaluedateDB_ID_atBackupTime] = attributevaluedateDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json ATTRIBUTEVALUEDATE file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<ATTRIBUTEVALUEDATE>id_atBckpTime_newID
// to compute new index
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) RestorePhaseTwo() {

	for _, attributevaluedateDB := range backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB {

		// next line of code is to avert unused variable compilation error
		_ = attributevaluedateDB

		// insertion point for reindexing pointers encoding
		// reindexing DEFINITION field
		if attributevaluedateDB.DEFINITIONID.Int64 != 0 {
			attributevaluedateDB.DEFINITIONID.Int64 = int64(BackRepoDEFINITIONid_atBckpTime_newID[uint(attributevaluedateDB.DEFINITIONID.Int64)])
			attributevaluedateDB.DEFINITIONID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoATTRIBUTEVALUEDATE.db.Model(attributevaluedateDB).Updates(*attributevaluedateDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoATTRIBUTEVALUEDATE.ResetReversePointers commits all staged instances of ATTRIBUTEVALUEDATE to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, attributevaluedate := range backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEPtr {
		backRepoATTRIBUTEVALUEDATE.ResetReversePointersInstance(backRepo, idx, attributevaluedate)
	}

	return
}

func (backRepoATTRIBUTEVALUEDATE *BackRepoATTRIBUTEVALUEDATEStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, attributevaluedate *models.ATTRIBUTEVALUEDATE) (Error error) {

	// fetch matching attributevaluedateDB
	if attributevaluedateDB, ok := backRepoATTRIBUTEVALUEDATE.Map_ATTRIBUTEVALUEDATEDBID_ATTRIBUTEVALUEDATEDB[idx]; ok {
		_ = attributevaluedateDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoATTRIBUTEVALUEDATEid_atBckpTime_newID map[uint]uint
