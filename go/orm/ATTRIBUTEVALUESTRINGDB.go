// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/thomaspeugeot/gongreqif/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_ATTRIBUTEVALUESTRING_sql sql.NullBool
var dummy_ATTRIBUTEVALUESTRING_time time.Duration
var dummy_ATTRIBUTEVALUESTRING_sort sort.Float64Slice

// ATTRIBUTEVALUESTRINGAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model attributevaluestringAPI
type ATTRIBUTEVALUESTRINGAPI struct {
	gorm.Model

	models.ATTRIBUTEVALUESTRING_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	ATTRIBUTEVALUESTRINGPointersEncoding ATTRIBUTEVALUESTRINGPointersEncoding
}

// ATTRIBUTEVALUESTRINGPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type ATTRIBUTEVALUESTRINGPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field DEFINITION is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	DEFINITIONID sql.NullInt64
}

// ATTRIBUTEVALUESTRINGDB describes a attributevaluestring in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model attributevaluestringDB
type ATTRIBUTEVALUESTRINGDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field attributevaluestringDB.Name
	Name_Data sql.NullString

	// Declation for basic field attributevaluestringDB.THEVALUEAttr
	THEVALUEAttr_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	ATTRIBUTEVALUESTRINGPointersEncoding
}

// ATTRIBUTEVALUESTRINGDBs arrays attributevaluestringDBs
// swagger:response attributevaluestringDBsResponse
type ATTRIBUTEVALUESTRINGDBs []ATTRIBUTEVALUESTRINGDB

// ATTRIBUTEVALUESTRINGDBResponse provides response
// swagger:response attributevaluestringDBResponse
type ATTRIBUTEVALUESTRINGDBResponse struct {
	ATTRIBUTEVALUESTRINGDB
}

// ATTRIBUTEVALUESTRINGWOP is a ATTRIBUTEVALUESTRING without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type ATTRIBUTEVALUESTRINGWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`

	THEVALUEAttr string `xlsx:"2"`
	// insertion for WOP pointer fields
}

var ATTRIBUTEVALUESTRING_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
	"THEVALUEAttr",
}

type BackRepoATTRIBUTEVALUESTRINGStruct struct {
	// stores ATTRIBUTEVALUESTRINGDB according to their gorm ID
	Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB map[uint]*ATTRIBUTEVALUESTRINGDB

	// stores ATTRIBUTEVALUESTRINGDB ID according to ATTRIBUTEVALUESTRING address
	Map_ATTRIBUTEVALUESTRINGPtr_ATTRIBUTEVALUESTRINGDBID map[*models.ATTRIBUTEVALUESTRING]uint

	// stores ATTRIBUTEVALUESTRING according to their gorm ID
	Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr map[uint]*models.ATTRIBUTEVALUESTRING

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoATTRIBUTEVALUESTRING.stage
	return
}

func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) GetDB() *gorm.DB {
	return backRepoATTRIBUTEVALUESTRING.db
}

// GetATTRIBUTEVALUESTRINGDBFromATTRIBUTEVALUESTRINGPtr is a handy function to access the back repo instance from the stage instance
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) GetATTRIBUTEVALUESTRINGDBFromATTRIBUTEVALUESTRINGPtr(attributevaluestring *models.ATTRIBUTEVALUESTRING) (attributevaluestringDB *ATTRIBUTEVALUESTRINGDB) {
	id := backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGPtr_ATTRIBUTEVALUESTRINGDBID[attributevaluestring]
	attributevaluestringDB = backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB[id]
	return
}

// BackRepoATTRIBUTEVALUESTRING.CommitPhaseOne commits all staged instances of ATTRIBUTEVALUESTRING to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for attributevaluestring := range stage.ATTRIBUTEVALUESTRINGs {
		backRepoATTRIBUTEVALUESTRING.CommitPhaseOneInstance(attributevaluestring)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, attributevaluestring := range backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr {
		if _, ok := stage.ATTRIBUTEVALUESTRINGs[attributevaluestring]; !ok {
			backRepoATTRIBUTEVALUESTRING.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoATTRIBUTEVALUESTRING.CommitDeleteInstance commits deletion of ATTRIBUTEVALUESTRING to the BackRepo
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) CommitDeleteInstance(id uint) (Error error) {

	attributevaluestring := backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr[id]

	// attributevaluestring is not staged anymore, remove attributevaluestringDB
	attributevaluestringDB := backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB[id]
	query := backRepoATTRIBUTEVALUESTRING.db.Unscoped().Delete(&attributevaluestringDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGPtr_ATTRIBUTEVALUESTRINGDBID, attributevaluestring)
	delete(backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr, id)
	delete(backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB, id)

	return
}

// BackRepoATTRIBUTEVALUESTRING.CommitPhaseOneInstance commits attributevaluestring staged instances of ATTRIBUTEVALUESTRING to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) CommitPhaseOneInstance(attributevaluestring *models.ATTRIBUTEVALUESTRING) (Error error) {

	// check if the attributevaluestring is not commited yet
	if _, ok := backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGPtr_ATTRIBUTEVALUESTRINGDBID[attributevaluestring]; ok {
		return
	}

	// initiate attributevaluestring
	var attributevaluestringDB ATTRIBUTEVALUESTRINGDB
	attributevaluestringDB.CopyBasicFieldsFromATTRIBUTEVALUESTRING(attributevaluestring)

	query := backRepoATTRIBUTEVALUESTRING.db.Create(&attributevaluestringDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGPtr_ATTRIBUTEVALUESTRINGDBID[attributevaluestring] = attributevaluestringDB.ID
	backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr[attributevaluestringDB.ID] = attributevaluestring
	backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB[attributevaluestringDB.ID] = &attributevaluestringDB

	return
}

// BackRepoATTRIBUTEVALUESTRING.CommitPhaseTwo commits all staged instances of ATTRIBUTEVALUESTRING to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, attributevaluestring := range backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr {
		backRepoATTRIBUTEVALUESTRING.CommitPhaseTwoInstance(backRepo, idx, attributevaluestring)
	}

	return
}

// BackRepoATTRIBUTEVALUESTRING.CommitPhaseTwoInstance commits {{structname }} of models.ATTRIBUTEVALUESTRING to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, attributevaluestring *models.ATTRIBUTEVALUESTRING) (Error error) {

	// fetch matching attributevaluestringDB
	if attributevaluestringDB, ok := backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB[idx]; ok {

		attributevaluestringDB.CopyBasicFieldsFromATTRIBUTEVALUESTRING(attributevaluestring)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value attributevaluestring.DEFINITION translates to updating the attributevaluestring.DEFINITIONID
		attributevaluestringDB.DEFINITIONID.Valid = true // allow for a 0 value (nil association)
		if attributevaluestring.DEFINITION != nil {
			if DEFINITIONId, ok := backRepo.BackRepoDEFINITION.Map_DEFINITIONPtr_DEFINITIONDBID[attributevaluestring.DEFINITION]; ok {
				attributevaluestringDB.DEFINITIONID.Int64 = int64(DEFINITIONId)
				attributevaluestringDB.DEFINITIONID.Valid = true
			}
		} else {
			attributevaluestringDB.DEFINITIONID.Int64 = 0
			attributevaluestringDB.DEFINITIONID.Valid = true
		}

		query := backRepoATTRIBUTEVALUESTRING.db.Save(&attributevaluestringDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown ATTRIBUTEVALUESTRING intance %s", attributevaluestring.Name))
		return err
	}

	return
}

// BackRepoATTRIBUTEVALUESTRING.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) CheckoutPhaseOne() (Error error) {

	attributevaluestringDBArray := make([]ATTRIBUTEVALUESTRINGDB, 0)
	query := backRepoATTRIBUTEVALUESTRING.db.Find(&attributevaluestringDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	attributevaluestringInstancesToBeRemovedFromTheStage := make(map[*models.ATTRIBUTEVALUESTRING]any)
	for key, value := range backRepoATTRIBUTEVALUESTRING.stage.ATTRIBUTEVALUESTRINGs {
		attributevaluestringInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, attributevaluestringDB := range attributevaluestringDBArray {
		backRepoATTRIBUTEVALUESTRING.CheckoutPhaseOneInstance(&attributevaluestringDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		attributevaluestring, ok := backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr[attributevaluestringDB.ID]
		if ok {
			delete(attributevaluestringInstancesToBeRemovedFromTheStage, attributevaluestring)
		}
	}

	// remove from stage and back repo's 3 maps all attributevaluestrings that are not in the checkout
	for attributevaluestring := range attributevaluestringInstancesToBeRemovedFromTheStage {
		attributevaluestring.Unstage(backRepoATTRIBUTEVALUESTRING.GetStage())

		// remove instance from the back repo 3 maps
		attributevaluestringID := backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGPtr_ATTRIBUTEVALUESTRINGDBID[attributevaluestring]
		delete(backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGPtr_ATTRIBUTEVALUESTRINGDBID, attributevaluestring)
		delete(backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB, attributevaluestringID)
		delete(backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr, attributevaluestringID)
	}

	return
}

// CheckoutPhaseOneInstance takes a attributevaluestringDB that has been found in the DB, updates the backRepo and stages the
// models version of the attributevaluestringDB
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) CheckoutPhaseOneInstance(attributevaluestringDB *ATTRIBUTEVALUESTRINGDB) (Error error) {

	attributevaluestring, ok := backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr[attributevaluestringDB.ID]
	if !ok {
		attributevaluestring = new(models.ATTRIBUTEVALUESTRING)

		backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr[attributevaluestringDB.ID] = attributevaluestring
		backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGPtr_ATTRIBUTEVALUESTRINGDBID[attributevaluestring] = attributevaluestringDB.ID

		// append model store with the new element
		attributevaluestring.Name = attributevaluestringDB.Name_Data.String
		attributevaluestring.Stage(backRepoATTRIBUTEVALUESTRING.GetStage())
	}
	attributevaluestringDB.CopyBasicFieldsToATTRIBUTEVALUESTRING(attributevaluestring)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	attributevaluestring.Stage(backRepoATTRIBUTEVALUESTRING.GetStage())

	// preserve pointer to attributevaluestringDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB)[attributevaluestringDB hold variable pointers
	attributevaluestringDB_Data := *attributevaluestringDB
	preservedPtrToATTRIBUTEVALUESTRING := &attributevaluestringDB_Data
	backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB[attributevaluestringDB.ID] = preservedPtrToATTRIBUTEVALUESTRING

	return
}

// BackRepoATTRIBUTEVALUESTRING.CheckoutPhaseTwo Checkouts all staged instances of ATTRIBUTEVALUESTRING to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, attributevaluestringDB := range backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB {
		backRepoATTRIBUTEVALUESTRING.CheckoutPhaseTwoInstance(backRepo, attributevaluestringDB)
	}
	return
}

// BackRepoATTRIBUTEVALUESTRING.CheckoutPhaseTwoInstance Checkouts staged instances of ATTRIBUTEVALUESTRING to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, attributevaluestringDB *ATTRIBUTEVALUESTRINGDB) (Error error) {

	attributevaluestring := backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr[attributevaluestringDB.ID]

	attributevaluestringDB.DecodePointers(backRepo, attributevaluestring)

	return
}

func (attributevaluestringDB *ATTRIBUTEVALUESTRINGDB) DecodePointers(backRepo *BackRepoStruct, attributevaluestring *models.ATTRIBUTEVALUESTRING) {

	// insertion point for checkout of pointer encoding
	// DEFINITION field
	attributevaluestring.DEFINITION = nil
	if attributevaluestringDB.DEFINITIONID.Int64 != 0 {
		attributevaluestring.DEFINITION = backRepo.BackRepoDEFINITION.Map_DEFINITIONDBID_DEFINITIONPtr[uint(attributevaluestringDB.DEFINITIONID.Int64)]
	}
	return
}

// CommitATTRIBUTEVALUESTRING allows commit of a single attributevaluestring (if already staged)
func (backRepo *BackRepoStruct) CommitATTRIBUTEVALUESTRING(attributevaluestring *models.ATTRIBUTEVALUESTRING) {
	backRepo.BackRepoATTRIBUTEVALUESTRING.CommitPhaseOneInstance(attributevaluestring)
	if id, ok := backRepo.BackRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGPtr_ATTRIBUTEVALUESTRINGDBID[attributevaluestring]; ok {
		backRepo.BackRepoATTRIBUTEVALUESTRING.CommitPhaseTwoInstance(backRepo, id, attributevaluestring)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitATTRIBUTEVALUESTRING allows checkout of a single attributevaluestring (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutATTRIBUTEVALUESTRING(attributevaluestring *models.ATTRIBUTEVALUESTRING) {
	// check if the attributevaluestring is staged
	if _, ok := backRepo.BackRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGPtr_ATTRIBUTEVALUESTRINGDBID[attributevaluestring]; ok {

		if id, ok := backRepo.BackRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGPtr_ATTRIBUTEVALUESTRINGDBID[attributevaluestring]; ok {
			var attributevaluestringDB ATTRIBUTEVALUESTRINGDB
			attributevaluestringDB.ID = id

			if err := backRepo.BackRepoATTRIBUTEVALUESTRING.db.First(&attributevaluestringDB, id).Error; err != nil {
				log.Fatalln("CheckoutATTRIBUTEVALUESTRING : Problem with getting object with id:", id)
			}
			backRepo.BackRepoATTRIBUTEVALUESTRING.CheckoutPhaseOneInstance(&attributevaluestringDB)
			backRepo.BackRepoATTRIBUTEVALUESTRING.CheckoutPhaseTwoInstance(backRepo, &attributevaluestringDB)
		}
	}
}

// CopyBasicFieldsFromATTRIBUTEVALUESTRING
func (attributevaluestringDB *ATTRIBUTEVALUESTRINGDB) CopyBasicFieldsFromATTRIBUTEVALUESTRING(attributevaluestring *models.ATTRIBUTEVALUESTRING) {
	// insertion point for fields commit

	attributevaluestringDB.Name_Data.String = attributevaluestring.Name
	attributevaluestringDB.Name_Data.Valid = true

	attributevaluestringDB.THEVALUEAttr_Data.String = attributevaluestring.THEVALUEAttr
	attributevaluestringDB.THEVALUEAttr_Data.Valid = true
}

// CopyBasicFieldsFromATTRIBUTEVALUESTRING_WOP
func (attributevaluestringDB *ATTRIBUTEVALUESTRINGDB) CopyBasicFieldsFromATTRIBUTEVALUESTRING_WOP(attributevaluestring *models.ATTRIBUTEVALUESTRING_WOP) {
	// insertion point for fields commit

	attributevaluestringDB.Name_Data.String = attributevaluestring.Name
	attributevaluestringDB.Name_Data.Valid = true

	attributevaluestringDB.THEVALUEAttr_Data.String = attributevaluestring.THEVALUEAttr
	attributevaluestringDB.THEVALUEAttr_Data.Valid = true
}

// CopyBasicFieldsFromATTRIBUTEVALUESTRINGWOP
func (attributevaluestringDB *ATTRIBUTEVALUESTRINGDB) CopyBasicFieldsFromATTRIBUTEVALUESTRINGWOP(attributevaluestring *ATTRIBUTEVALUESTRINGWOP) {
	// insertion point for fields commit

	attributevaluestringDB.Name_Data.String = attributevaluestring.Name
	attributevaluestringDB.Name_Data.Valid = true

	attributevaluestringDB.THEVALUEAttr_Data.String = attributevaluestring.THEVALUEAttr
	attributevaluestringDB.THEVALUEAttr_Data.Valid = true
}

// CopyBasicFieldsToATTRIBUTEVALUESTRING
func (attributevaluestringDB *ATTRIBUTEVALUESTRINGDB) CopyBasicFieldsToATTRIBUTEVALUESTRING(attributevaluestring *models.ATTRIBUTEVALUESTRING) {
	// insertion point for checkout of basic fields (back repo to stage)
	attributevaluestring.Name = attributevaluestringDB.Name_Data.String
	attributevaluestring.THEVALUEAttr = attributevaluestringDB.THEVALUEAttr_Data.String
}

// CopyBasicFieldsToATTRIBUTEVALUESTRING_WOP
func (attributevaluestringDB *ATTRIBUTEVALUESTRINGDB) CopyBasicFieldsToATTRIBUTEVALUESTRING_WOP(attributevaluestring *models.ATTRIBUTEVALUESTRING_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	attributevaluestring.Name = attributevaluestringDB.Name_Data.String
	attributevaluestring.THEVALUEAttr = attributevaluestringDB.THEVALUEAttr_Data.String
}

// CopyBasicFieldsToATTRIBUTEVALUESTRINGWOP
func (attributevaluestringDB *ATTRIBUTEVALUESTRINGDB) CopyBasicFieldsToATTRIBUTEVALUESTRINGWOP(attributevaluestring *ATTRIBUTEVALUESTRINGWOP) {
	attributevaluestring.ID = int(attributevaluestringDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	attributevaluestring.Name = attributevaluestringDB.Name_Data.String
	attributevaluestring.THEVALUEAttr = attributevaluestringDB.THEVALUEAttr_Data.String
}

// Backup generates a json file from a slice of all ATTRIBUTEVALUESTRINGDB instances in the backrepo
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "ATTRIBUTEVALUESTRINGDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*ATTRIBUTEVALUESTRINGDB, 0)
	for _, attributevaluestringDB := range backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB {
		forBackup = append(forBackup, attributevaluestringDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json ATTRIBUTEVALUESTRING ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json ATTRIBUTEVALUESTRING file", err.Error())
	}
}

// Backup generates a json file from a slice of all ATTRIBUTEVALUESTRINGDB instances in the backrepo
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*ATTRIBUTEVALUESTRINGDB, 0)
	for _, attributevaluestringDB := range backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB {
		forBackup = append(forBackup, attributevaluestringDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("ATTRIBUTEVALUESTRING")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&ATTRIBUTEVALUESTRING_Fields, -1)
	for _, attributevaluestringDB := range forBackup {

		var attributevaluestringWOP ATTRIBUTEVALUESTRINGWOP
		attributevaluestringDB.CopyBasicFieldsToATTRIBUTEVALUESTRINGWOP(&attributevaluestringWOP)

		row := sh.AddRow()
		row.WriteStruct(&attributevaluestringWOP, -1)
	}
}

// RestoreXL from the "ATTRIBUTEVALUESTRING" sheet all ATTRIBUTEVALUESTRINGDB instances
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoATTRIBUTEVALUESTRINGid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["ATTRIBUTEVALUESTRING"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoATTRIBUTEVALUESTRING.rowVisitorATTRIBUTEVALUESTRING)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) rowVisitorATTRIBUTEVALUESTRING(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var attributevaluestringWOP ATTRIBUTEVALUESTRINGWOP
		row.ReadStruct(&attributevaluestringWOP)

		// add the unmarshalled struct to the stage
		attributevaluestringDB := new(ATTRIBUTEVALUESTRINGDB)
		attributevaluestringDB.CopyBasicFieldsFromATTRIBUTEVALUESTRINGWOP(&attributevaluestringWOP)

		attributevaluestringDB_ID_atBackupTime := attributevaluestringDB.ID
		attributevaluestringDB.ID = 0
		query := backRepoATTRIBUTEVALUESTRING.db.Create(attributevaluestringDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB[attributevaluestringDB.ID] = attributevaluestringDB
		BackRepoATTRIBUTEVALUESTRINGid_atBckpTime_newID[attributevaluestringDB_ID_atBackupTime] = attributevaluestringDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "ATTRIBUTEVALUESTRINGDB.json" in dirPath that stores an array
// of ATTRIBUTEVALUESTRINGDB and stores it in the database
// the map BackRepoATTRIBUTEVALUESTRINGid_atBckpTime_newID is updated accordingly
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoATTRIBUTEVALUESTRINGid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "ATTRIBUTEVALUESTRINGDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json ATTRIBUTEVALUESTRING file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*ATTRIBUTEVALUESTRINGDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB
	for _, attributevaluestringDB := range forRestore {

		attributevaluestringDB_ID_atBackupTime := attributevaluestringDB.ID
		attributevaluestringDB.ID = 0
		query := backRepoATTRIBUTEVALUESTRING.db.Create(attributevaluestringDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB[attributevaluestringDB.ID] = attributevaluestringDB
		BackRepoATTRIBUTEVALUESTRINGid_atBckpTime_newID[attributevaluestringDB_ID_atBackupTime] = attributevaluestringDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json ATTRIBUTEVALUESTRING file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<ATTRIBUTEVALUESTRING>id_atBckpTime_newID
// to compute new index
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) RestorePhaseTwo() {

	for _, attributevaluestringDB := range backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB {

		// next line of code is to avert unused variable compilation error
		_ = attributevaluestringDB

		// insertion point for reindexing pointers encoding
		// reindexing DEFINITION field
		if attributevaluestringDB.DEFINITIONID.Int64 != 0 {
			attributevaluestringDB.DEFINITIONID.Int64 = int64(BackRepoDEFINITIONid_atBckpTime_newID[uint(attributevaluestringDB.DEFINITIONID.Int64)])
			attributevaluestringDB.DEFINITIONID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoATTRIBUTEVALUESTRING.db.Model(attributevaluestringDB).Updates(*attributevaluestringDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoATTRIBUTEVALUESTRING.ResetReversePointers commits all staged instances of ATTRIBUTEVALUESTRING to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, attributevaluestring := range backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGPtr {
		backRepoATTRIBUTEVALUESTRING.ResetReversePointersInstance(backRepo, idx, attributevaluestring)
	}

	return
}

func (backRepoATTRIBUTEVALUESTRING *BackRepoATTRIBUTEVALUESTRINGStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, attributevaluestring *models.ATTRIBUTEVALUESTRING) (Error error) {

	// fetch matching attributevaluestringDB
	if attributevaluestringDB, ok := backRepoATTRIBUTEVALUESTRING.Map_ATTRIBUTEVALUESTRINGDBID_ATTRIBUTEVALUESTRINGDB[idx]; ok {
		_ = attributevaluestringDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoATTRIBUTEVALUESTRINGid_atBckpTime_newID map[uint]uint
