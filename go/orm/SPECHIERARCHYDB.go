// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/thomaspeugeot/gongreqif/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_SPECHIERARCHY_sql sql.NullBool
var dummy_SPECHIERARCHY_time time.Duration
var dummy_SPECHIERARCHY_sort sort.Float64Slice

// SPECHIERARCHYAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model spechierarchyAPI
type SPECHIERARCHYAPI struct {
	gorm.Model

	models.SPECHIERARCHY_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	SPECHIERARCHYPointersEncoding SPECHIERARCHYPointersEncoding
}

// SPECHIERARCHYPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type SPECHIERARCHYPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field ALTERNATIVEID is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	ALTERNATIVEIDID sql.NullInt64

	// field CHILDREN is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	CHILDRENID sql.NullInt64

	// field EDITABLEATTS is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	EDITABLEATTSID sql.NullInt64

	// field OBJECT is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	OBJECTID sql.NullInt64
}

// SPECHIERARCHYDB describes a spechierarchy in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model spechierarchyDB
type SPECHIERARCHYDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field spechierarchyDB.Name
	Name_Data sql.NullString

	// Declation for basic field spechierarchyDB.DESCAttr
	DESCAttr_Data sql.NullString

	// Declation for basic field spechierarchyDB.IDENTIFIERAttr
	IDENTIFIERAttr_Data sql.NullString

	// Declation for basic field spechierarchyDB.ISEDITABLEAttr
	// provide the sql storage for the boolan
	ISEDITABLEAttr_Data sql.NullBool

	// Declation for basic field spechierarchyDB.ISTABLEINTERNALAttr
	// provide the sql storage for the boolan
	ISTABLEINTERNALAttr_Data sql.NullBool

	// Declation for basic field spechierarchyDB.LASTCHANGEAttr
	LASTCHANGEAttr_Data sql.NullString

	// Declation for basic field spechierarchyDB.LONGNAMEAttr
	LONGNAMEAttr_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	SPECHIERARCHYPointersEncoding
}

// SPECHIERARCHYDBs arrays spechierarchyDBs
// swagger:response spechierarchyDBsResponse
type SPECHIERARCHYDBs []SPECHIERARCHYDB

// SPECHIERARCHYDBResponse provides response
// swagger:response spechierarchyDBResponse
type SPECHIERARCHYDBResponse struct {
	SPECHIERARCHYDB
}

// SPECHIERARCHYWOP is a SPECHIERARCHY without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type SPECHIERARCHYWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`

	DESCAttr string `xlsx:"2"`

	IDENTIFIERAttr string `xlsx:"3"`

	ISEDITABLEAttr bool `xlsx:"4"`

	ISTABLEINTERNALAttr bool `xlsx:"5"`

	LASTCHANGEAttr string `xlsx:"6"`

	LONGNAMEAttr string `xlsx:"7"`
	// insertion for WOP pointer fields
}

var SPECHIERARCHY_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
	"DESCAttr",
	"IDENTIFIERAttr",
	"ISEDITABLEAttr",
	"ISTABLEINTERNALAttr",
	"LASTCHANGEAttr",
	"LONGNAMEAttr",
}

type BackRepoSPECHIERARCHYStruct struct {
	// stores SPECHIERARCHYDB according to their gorm ID
	Map_SPECHIERARCHYDBID_SPECHIERARCHYDB map[uint]*SPECHIERARCHYDB

	// stores SPECHIERARCHYDB ID according to SPECHIERARCHY address
	Map_SPECHIERARCHYPtr_SPECHIERARCHYDBID map[*models.SPECHIERARCHY]uint

	// stores SPECHIERARCHY according to their gorm ID
	Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr map[uint]*models.SPECHIERARCHY

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoSPECHIERARCHY.stage
	return
}

func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) GetDB() *gorm.DB {
	return backRepoSPECHIERARCHY.db
}

// GetSPECHIERARCHYDBFromSPECHIERARCHYPtr is a handy function to access the back repo instance from the stage instance
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) GetSPECHIERARCHYDBFromSPECHIERARCHYPtr(spechierarchy *models.SPECHIERARCHY) (spechierarchyDB *SPECHIERARCHYDB) {
	id := backRepoSPECHIERARCHY.Map_SPECHIERARCHYPtr_SPECHIERARCHYDBID[spechierarchy]
	spechierarchyDB = backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB[id]
	return
}

// BackRepoSPECHIERARCHY.CommitPhaseOne commits all staged instances of SPECHIERARCHY to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for spechierarchy := range stage.SPECHIERARCHYs {
		backRepoSPECHIERARCHY.CommitPhaseOneInstance(spechierarchy)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, spechierarchy := range backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr {
		if _, ok := stage.SPECHIERARCHYs[spechierarchy]; !ok {
			backRepoSPECHIERARCHY.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoSPECHIERARCHY.CommitDeleteInstance commits deletion of SPECHIERARCHY to the BackRepo
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) CommitDeleteInstance(id uint) (Error error) {

	spechierarchy := backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr[id]

	// spechierarchy is not staged anymore, remove spechierarchyDB
	spechierarchyDB := backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB[id]
	query := backRepoSPECHIERARCHY.db.Unscoped().Delete(&spechierarchyDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoSPECHIERARCHY.Map_SPECHIERARCHYPtr_SPECHIERARCHYDBID, spechierarchy)
	delete(backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr, id)
	delete(backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB, id)

	return
}

// BackRepoSPECHIERARCHY.CommitPhaseOneInstance commits spechierarchy staged instances of SPECHIERARCHY to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) CommitPhaseOneInstance(spechierarchy *models.SPECHIERARCHY) (Error error) {

	// check if the spechierarchy is not commited yet
	if _, ok := backRepoSPECHIERARCHY.Map_SPECHIERARCHYPtr_SPECHIERARCHYDBID[spechierarchy]; ok {
		return
	}

	// initiate spechierarchy
	var spechierarchyDB SPECHIERARCHYDB
	spechierarchyDB.CopyBasicFieldsFromSPECHIERARCHY(spechierarchy)

	query := backRepoSPECHIERARCHY.db.Create(&spechierarchyDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoSPECHIERARCHY.Map_SPECHIERARCHYPtr_SPECHIERARCHYDBID[spechierarchy] = spechierarchyDB.ID
	backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr[spechierarchyDB.ID] = spechierarchy
	backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB[spechierarchyDB.ID] = &spechierarchyDB

	return
}

// BackRepoSPECHIERARCHY.CommitPhaseTwo commits all staged instances of SPECHIERARCHY to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, spechierarchy := range backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr {
		backRepoSPECHIERARCHY.CommitPhaseTwoInstance(backRepo, idx, spechierarchy)
	}

	return
}

// BackRepoSPECHIERARCHY.CommitPhaseTwoInstance commits {{structname }} of models.SPECHIERARCHY to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, spechierarchy *models.SPECHIERARCHY) (Error error) {

	// fetch matching spechierarchyDB
	if spechierarchyDB, ok := backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB[idx]; ok {

		spechierarchyDB.CopyBasicFieldsFromSPECHIERARCHY(spechierarchy)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value spechierarchy.ALTERNATIVEID translates to updating the spechierarchy.ALTERNATIVEIDID
		spechierarchyDB.ALTERNATIVEIDID.Valid = true // allow for a 0 value (nil association)
		if spechierarchy.ALTERNATIVEID != nil {
			if ALTERNATIVEIDId, ok := backRepo.BackRepoALTERNATIVEID.Map_ALTERNATIVEIDPtr_ALTERNATIVEIDDBID[spechierarchy.ALTERNATIVEID]; ok {
				spechierarchyDB.ALTERNATIVEIDID.Int64 = int64(ALTERNATIVEIDId)
				spechierarchyDB.ALTERNATIVEIDID.Valid = true
			}
		} else {
			spechierarchyDB.ALTERNATIVEIDID.Int64 = 0
			spechierarchyDB.ALTERNATIVEIDID.Valid = true
		}

		// commit pointer value spechierarchy.CHILDREN translates to updating the spechierarchy.CHILDRENID
		spechierarchyDB.CHILDRENID.Valid = true // allow for a 0 value (nil association)
		if spechierarchy.CHILDREN != nil {
			if CHILDRENId, ok := backRepo.BackRepoCHILDREN.Map_CHILDRENPtr_CHILDRENDBID[spechierarchy.CHILDREN]; ok {
				spechierarchyDB.CHILDRENID.Int64 = int64(CHILDRENId)
				spechierarchyDB.CHILDRENID.Valid = true
			}
		} else {
			spechierarchyDB.CHILDRENID.Int64 = 0
			spechierarchyDB.CHILDRENID.Valid = true
		}

		// commit pointer value spechierarchy.EDITABLEATTS translates to updating the spechierarchy.EDITABLEATTSID
		spechierarchyDB.EDITABLEATTSID.Valid = true // allow for a 0 value (nil association)
		if spechierarchy.EDITABLEATTS != nil {
			if EDITABLEATTSId, ok := backRepo.BackRepoEDITABLEATTS.Map_EDITABLEATTSPtr_EDITABLEATTSDBID[spechierarchy.EDITABLEATTS]; ok {
				spechierarchyDB.EDITABLEATTSID.Int64 = int64(EDITABLEATTSId)
				spechierarchyDB.EDITABLEATTSID.Valid = true
			}
		} else {
			spechierarchyDB.EDITABLEATTSID.Int64 = 0
			spechierarchyDB.EDITABLEATTSID.Valid = true
		}

		// commit pointer value spechierarchy.OBJECT translates to updating the spechierarchy.OBJECTID
		spechierarchyDB.OBJECTID.Valid = true // allow for a 0 value (nil association)
		if spechierarchy.OBJECT != nil {
			if OBJECTId, ok := backRepo.BackRepoOBJECT.Map_OBJECTPtr_OBJECTDBID[spechierarchy.OBJECT]; ok {
				spechierarchyDB.OBJECTID.Int64 = int64(OBJECTId)
				spechierarchyDB.OBJECTID.Valid = true
			}
		} else {
			spechierarchyDB.OBJECTID.Int64 = 0
			spechierarchyDB.OBJECTID.Valid = true
		}

		query := backRepoSPECHIERARCHY.db.Save(&spechierarchyDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown SPECHIERARCHY intance %s", spechierarchy.Name))
		return err
	}

	return
}

// BackRepoSPECHIERARCHY.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) CheckoutPhaseOne() (Error error) {

	spechierarchyDBArray := make([]SPECHIERARCHYDB, 0)
	query := backRepoSPECHIERARCHY.db.Find(&spechierarchyDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	spechierarchyInstancesToBeRemovedFromTheStage := make(map[*models.SPECHIERARCHY]any)
	for key, value := range backRepoSPECHIERARCHY.stage.SPECHIERARCHYs {
		spechierarchyInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, spechierarchyDB := range spechierarchyDBArray {
		backRepoSPECHIERARCHY.CheckoutPhaseOneInstance(&spechierarchyDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		spechierarchy, ok := backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr[spechierarchyDB.ID]
		if ok {
			delete(spechierarchyInstancesToBeRemovedFromTheStage, spechierarchy)
		}
	}

	// remove from stage and back repo's 3 maps all spechierarchys that are not in the checkout
	for spechierarchy := range spechierarchyInstancesToBeRemovedFromTheStage {
		spechierarchy.Unstage(backRepoSPECHIERARCHY.GetStage())

		// remove instance from the back repo 3 maps
		spechierarchyID := backRepoSPECHIERARCHY.Map_SPECHIERARCHYPtr_SPECHIERARCHYDBID[spechierarchy]
		delete(backRepoSPECHIERARCHY.Map_SPECHIERARCHYPtr_SPECHIERARCHYDBID, spechierarchy)
		delete(backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB, spechierarchyID)
		delete(backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr, spechierarchyID)
	}

	return
}

// CheckoutPhaseOneInstance takes a spechierarchyDB that has been found in the DB, updates the backRepo and stages the
// models version of the spechierarchyDB
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) CheckoutPhaseOneInstance(spechierarchyDB *SPECHIERARCHYDB) (Error error) {

	spechierarchy, ok := backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr[spechierarchyDB.ID]
	if !ok {
		spechierarchy = new(models.SPECHIERARCHY)

		backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr[spechierarchyDB.ID] = spechierarchy
		backRepoSPECHIERARCHY.Map_SPECHIERARCHYPtr_SPECHIERARCHYDBID[spechierarchy] = spechierarchyDB.ID

		// append model store with the new element
		spechierarchy.Name = spechierarchyDB.Name_Data.String
		spechierarchy.Stage(backRepoSPECHIERARCHY.GetStage())
	}
	spechierarchyDB.CopyBasicFieldsToSPECHIERARCHY(spechierarchy)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	spechierarchy.Stage(backRepoSPECHIERARCHY.GetStage())

	// preserve pointer to spechierarchyDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_SPECHIERARCHYDBID_SPECHIERARCHYDB)[spechierarchyDB hold variable pointers
	spechierarchyDB_Data := *spechierarchyDB
	preservedPtrToSPECHIERARCHY := &spechierarchyDB_Data
	backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB[spechierarchyDB.ID] = preservedPtrToSPECHIERARCHY

	return
}

// BackRepoSPECHIERARCHY.CheckoutPhaseTwo Checkouts all staged instances of SPECHIERARCHY to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, spechierarchyDB := range backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB {
		backRepoSPECHIERARCHY.CheckoutPhaseTwoInstance(backRepo, spechierarchyDB)
	}
	return
}

// BackRepoSPECHIERARCHY.CheckoutPhaseTwoInstance Checkouts staged instances of SPECHIERARCHY to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, spechierarchyDB *SPECHIERARCHYDB) (Error error) {

	spechierarchy := backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr[spechierarchyDB.ID]

	spechierarchyDB.DecodePointers(backRepo, spechierarchy)

	return
}

func (spechierarchyDB *SPECHIERARCHYDB) DecodePointers(backRepo *BackRepoStruct, spechierarchy *models.SPECHIERARCHY) {

	// insertion point for checkout of pointer encoding
	// ALTERNATIVEID field
	spechierarchy.ALTERNATIVEID = nil
	if spechierarchyDB.ALTERNATIVEIDID.Int64 != 0 {
		spechierarchy.ALTERNATIVEID = backRepo.BackRepoALTERNATIVEID.Map_ALTERNATIVEIDDBID_ALTERNATIVEIDPtr[uint(spechierarchyDB.ALTERNATIVEIDID.Int64)]
	}
	// CHILDREN field
	spechierarchy.CHILDREN = nil
	if spechierarchyDB.CHILDRENID.Int64 != 0 {
		spechierarchy.CHILDREN = backRepo.BackRepoCHILDREN.Map_CHILDRENDBID_CHILDRENPtr[uint(spechierarchyDB.CHILDRENID.Int64)]
	}
	// EDITABLEATTS field
	spechierarchy.EDITABLEATTS = nil
	if spechierarchyDB.EDITABLEATTSID.Int64 != 0 {
		spechierarchy.EDITABLEATTS = backRepo.BackRepoEDITABLEATTS.Map_EDITABLEATTSDBID_EDITABLEATTSPtr[uint(spechierarchyDB.EDITABLEATTSID.Int64)]
	}
	// OBJECT field
	spechierarchy.OBJECT = nil
	if spechierarchyDB.OBJECTID.Int64 != 0 {
		spechierarchy.OBJECT = backRepo.BackRepoOBJECT.Map_OBJECTDBID_OBJECTPtr[uint(spechierarchyDB.OBJECTID.Int64)]
	}
	return
}

// CommitSPECHIERARCHY allows commit of a single spechierarchy (if already staged)
func (backRepo *BackRepoStruct) CommitSPECHIERARCHY(spechierarchy *models.SPECHIERARCHY) {
	backRepo.BackRepoSPECHIERARCHY.CommitPhaseOneInstance(spechierarchy)
	if id, ok := backRepo.BackRepoSPECHIERARCHY.Map_SPECHIERARCHYPtr_SPECHIERARCHYDBID[spechierarchy]; ok {
		backRepo.BackRepoSPECHIERARCHY.CommitPhaseTwoInstance(backRepo, id, spechierarchy)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitSPECHIERARCHY allows checkout of a single spechierarchy (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutSPECHIERARCHY(spechierarchy *models.SPECHIERARCHY) {
	// check if the spechierarchy is staged
	if _, ok := backRepo.BackRepoSPECHIERARCHY.Map_SPECHIERARCHYPtr_SPECHIERARCHYDBID[spechierarchy]; ok {

		if id, ok := backRepo.BackRepoSPECHIERARCHY.Map_SPECHIERARCHYPtr_SPECHIERARCHYDBID[spechierarchy]; ok {
			var spechierarchyDB SPECHIERARCHYDB
			spechierarchyDB.ID = id

			if err := backRepo.BackRepoSPECHIERARCHY.db.First(&spechierarchyDB, id).Error; err != nil {
				log.Fatalln("CheckoutSPECHIERARCHY : Problem with getting object with id:", id)
			}
			backRepo.BackRepoSPECHIERARCHY.CheckoutPhaseOneInstance(&spechierarchyDB)
			backRepo.BackRepoSPECHIERARCHY.CheckoutPhaseTwoInstance(backRepo, &spechierarchyDB)
		}
	}
}

// CopyBasicFieldsFromSPECHIERARCHY
func (spechierarchyDB *SPECHIERARCHYDB) CopyBasicFieldsFromSPECHIERARCHY(spechierarchy *models.SPECHIERARCHY) {
	// insertion point for fields commit

	spechierarchyDB.Name_Data.String = spechierarchy.Name
	spechierarchyDB.Name_Data.Valid = true

	spechierarchyDB.DESCAttr_Data.String = spechierarchy.DESCAttr
	spechierarchyDB.DESCAttr_Data.Valid = true

	spechierarchyDB.IDENTIFIERAttr_Data.String = spechierarchy.IDENTIFIERAttr
	spechierarchyDB.IDENTIFIERAttr_Data.Valid = true

	spechierarchyDB.ISEDITABLEAttr_Data.Bool = spechierarchy.ISEDITABLEAttr
	spechierarchyDB.ISEDITABLEAttr_Data.Valid = true

	spechierarchyDB.ISTABLEINTERNALAttr_Data.Bool = spechierarchy.ISTABLEINTERNALAttr
	spechierarchyDB.ISTABLEINTERNALAttr_Data.Valid = true

	spechierarchyDB.LASTCHANGEAttr_Data.String = spechierarchy.LASTCHANGEAttr
	spechierarchyDB.LASTCHANGEAttr_Data.Valid = true

	spechierarchyDB.LONGNAMEAttr_Data.String = spechierarchy.LONGNAMEAttr
	spechierarchyDB.LONGNAMEAttr_Data.Valid = true
}

// CopyBasicFieldsFromSPECHIERARCHY_WOP
func (spechierarchyDB *SPECHIERARCHYDB) CopyBasicFieldsFromSPECHIERARCHY_WOP(spechierarchy *models.SPECHIERARCHY_WOP) {
	// insertion point for fields commit

	spechierarchyDB.Name_Data.String = spechierarchy.Name
	spechierarchyDB.Name_Data.Valid = true

	spechierarchyDB.DESCAttr_Data.String = spechierarchy.DESCAttr
	spechierarchyDB.DESCAttr_Data.Valid = true

	spechierarchyDB.IDENTIFIERAttr_Data.String = spechierarchy.IDENTIFIERAttr
	spechierarchyDB.IDENTIFIERAttr_Data.Valid = true

	spechierarchyDB.ISEDITABLEAttr_Data.Bool = spechierarchy.ISEDITABLEAttr
	spechierarchyDB.ISEDITABLEAttr_Data.Valid = true

	spechierarchyDB.ISTABLEINTERNALAttr_Data.Bool = spechierarchy.ISTABLEINTERNALAttr
	spechierarchyDB.ISTABLEINTERNALAttr_Data.Valid = true

	spechierarchyDB.LASTCHANGEAttr_Data.String = spechierarchy.LASTCHANGEAttr
	spechierarchyDB.LASTCHANGEAttr_Data.Valid = true

	spechierarchyDB.LONGNAMEAttr_Data.String = spechierarchy.LONGNAMEAttr
	spechierarchyDB.LONGNAMEAttr_Data.Valid = true
}

// CopyBasicFieldsFromSPECHIERARCHYWOP
func (spechierarchyDB *SPECHIERARCHYDB) CopyBasicFieldsFromSPECHIERARCHYWOP(spechierarchy *SPECHIERARCHYWOP) {
	// insertion point for fields commit

	spechierarchyDB.Name_Data.String = spechierarchy.Name
	spechierarchyDB.Name_Data.Valid = true

	spechierarchyDB.DESCAttr_Data.String = spechierarchy.DESCAttr
	spechierarchyDB.DESCAttr_Data.Valid = true

	spechierarchyDB.IDENTIFIERAttr_Data.String = spechierarchy.IDENTIFIERAttr
	spechierarchyDB.IDENTIFIERAttr_Data.Valid = true

	spechierarchyDB.ISEDITABLEAttr_Data.Bool = spechierarchy.ISEDITABLEAttr
	spechierarchyDB.ISEDITABLEAttr_Data.Valid = true

	spechierarchyDB.ISTABLEINTERNALAttr_Data.Bool = spechierarchy.ISTABLEINTERNALAttr
	spechierarchyDB.ISTABLEINTERNALAttr_Data.Valid = true

	spechierarchyDB.LASTCHANGEAttr_Data.String = spechierarchy.LASTCHANGEAttr
	spechierarchyDB.LASTCHANGEAttr_Data.Valid = true

	spechierarchyDB.LONGNAMEAttr_Data.String = spechierarchy.LONGNAMEAttr
	spechierarchyDB.LONGNAMEAttr_Data.Valid = true
}

// CopyBasicFieldsToSPECHIERARCHY
func (spechierarchyDB *SPECHIERARCHYDB) CopyBasicFieldsToSPECHIERARCHY(spechierarchy *models.SPECHIERARCHY) {
	// insertion point for checkout of basic fields (back repo to stage)
	spechierarchy.Name = spechierarchyDB.Name_Data.String
	spechierarchy.DESCAttr = spechierarchyDB.DESCAttr_Data.String
	spechierarchy.IDENTIFIERAttr = spechierarchyDB.IDENTIFIERAttr_Data.String
	spechierarchy.ISEDITABLEAttr = spechierarchyDB.ISEDITABLEAttr_Data.Bool
	spechierarchy.ISTABLEINTERNALAttr = spechierarchyDB.ISTABLEINTERNALAttr_Data.Bool
	spechierarchy.LASTCHANGEAttr = spechierarchyDB.LASTCHANGEAttr_Data.String
	spechierarchy.LONGNAMEAttr = spechierarchyDB.LONGNAMEAttr_Data.String
}

// CopyBasicFieldsToSPECHIERARCHY_WOP
func (spechierarchyDB *SPECHIERARCHYDB) CopyBasicFieldsToSPECHIERARCHY_WOP(spechierarchy *models.SPECHIERARCHY_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	spechierarchy.Name = spechierarchyDB.Name_Data.String
	spechierarchy.DESCAttr = spechierarchyDB.DESCAttr_Data.String
	spechierarchy.IDENTIFIERAttr = spechierarchyDB.IDENTIFIERAttr_Data.String
	spechierarchy.ISEDITABLEAttr = spechierarchyDB.ISEDITABLEAttr_Data.Bool
	spechierarchy.ISTABLEINTERNALAttr = spechierarchyDB.ISTABLEINTERNALAttr_Data.Bool
	spechierarchy.LASTCHANGEAttr = spechierarchyDB.LASTCHANGEAttr_Data.String
	spechierarchy.LONGNAMEAttr = spechierarchyDB.LONGNAMEAttr_Data.String
}

// CopyBasicFieldsToSPECHIERARCHYWOP
func (spechierarchyDB *SPECHIERARCHYDB) CopyBasicFieldsToSPECHIERARCHYWOP(spechierarchy *SPECHIERARCHYWOP) {
	spechierarchy.ID = int(spechierarchyDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	spechierarchy.Name = spechierarchyDB.Name_Data.String
	spechierarchy.DESCAttr = spechierarchyDB.DESCAttr_Data.String
	spechierarchy.IDENTIFIERAttr = spechierarchyDB.IDENTIFIERAttr_Data.String
	spechierarchy.ISEDITABLEAttr = spechierarchyDB.ISEDITABLEAttr_Data.Bool
	spechierarchy.ISTABLEINTERNALAttr = spechierarchyDB.ISTABLEINTERNALAttr_Data.Bool
	spechierarchy.LASTCHANGEAttr = spechierarchyDB.LASTCHANGEAttr_Data.String
	spechierarchy.LONGNAMEAttr = spechierarchyDB.LONGNAMEAttr_Data.String
}

// Backup generates a json file from a slice of all SPECHIERARCHYDB instances in the backrepo
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "SPECHIERARCHYDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*SPECHIERARCHYDB, 0)
	for _, spechierarchyDB := range backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB {
		forBackup = append(forBackup, spechierarchyDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json SPECHIERARCHY ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json SPECHIERARCHY file", err.Error())
	}
}

// Backup generates a json file from a slice of all SPECHIERARCHYDB instances in the backrepo
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*SPECHIERARCHYDB, 0)
	for _, spechierarchyDB := range backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB {
		forBackup = append(forBackup, spechierarchyDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("SPECHIERARCHY")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&SPECHIERARCHY_Fields, -1)
	for _, spechierarchyDB := range forBackup {

		var spechierarchyWOP SPECHIERARCHYWOP
		spechierarchyDB.CopyBasicFieldsToSPECHIERARCHYWOP(&spechierarchyWOP)

		row := sh.AddRow()
		row.WriteStruct(&spechierarchyWOP, -1)
	}
}

// RestoreXL from the "SPECHIERARCHY" sheet all SPECHIERARCHYDB instances
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoSPECHIERARCHYid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["SPECHIERARCHY"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoSPECHIERARCHY.rowVisitorSPECHIERARCHY)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) rowVisitorSPECHIERARCHY(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var spechierarchyWOP SPECHIERARCHYWOP
		row.ReadStruct(&spechierarchyWOP)

		// add the unmarshalled struct to the stage
		spechierarchyDB := new(SPECHIERARCHYDB)
		spechierarchyDB.CopyBasicFieldsFromSPECHIERARCHYWOP(&spechierarchyWOP)

		spechierarchyDB_ID_atBackupTime := spechierarchyDB.ID
		spechierarchyDB.ID = 0
		query := backRepoSPECHIERARCHY.db.Create(spechierarchyDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB[spechierarchyDB.ID] = spechierarchyDB
		BackRepoSPECHIERARCHYid_atBckpTime_newID[spechierarchyDB_ID_atBackupTime] = spechierarchyDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "SPECHIERARCHYDB.json" in dirPath that stores an array
// of SPECHIERARCHYDB and stores it in the database
// the map BackRepoSPECHIERARCHYid_atBckpTime_newID is updated accordingly
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoSPECHIERARCHYid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "SPECHIERARCHYDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json SPECHIERARCHY file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*SPECHIERARCHYDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_SPECHIERARCHYDBID_SPECHIERARCHYDB
	for _, spechierarchyDB := range forRestore {

		spechierarchyDB_ID_atBackupTime := spechierarchyDB.ID
		spechierarchyDB.ID = 0
		query := backRepoSPECHIERARCHY.db.Create(spechierarchyDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB[spechierarchyDB.ID] = spechierarchyDB
		BackRepoSPECHIERARCHYid_atBckpTime_newID[spechierarchyDB_ID_atBackupTime] = spechierarchyDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json SPECHIERARCHY file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<SPECHIERARCHY>id_atBckpTime_newID
// to compute new index
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) RestorePhaseTwo() {

	for _, spechierarchyDB := range backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB {

		// next line of code is to avert unused variable compilation error
		_ = spechierarchyDB

		// insertion point for reindexing pointers encoding
		// reindexing ALTERNATIVEID field
		if spechierarchyDB.ALTERNATIVEIDID.Int64 != 0 {
			spechierarchyDB.ALTERNATIVEIDID.Int64 = int64(BackRepoALTERNATIVEIDid_atBckpTime_newID[uint(spechierarchyDB.ALTERNATIVEIDID.Int64)])
			spechierarchyDB.ALTERNATIVEIDID.Valid = true
		}

		// reindexing CHILDREN field
		if spechierarchyDB.CHILDRENID.Int64 != 0 {
			spechierarchyDB.CHILDRENID.Int64 = int64(BackRepoCHILDRENid_atBckpTime_newID[uint(spechierarchyDB.CHILDRENID.Int64)])
			spechierarchyDB.CHILDRENID.Valid = true
		}

		// reindexing EDITABLEATTS field
		if spechierarchyDB.EDITABLEATTSID.Int64 != 0 {
			spechierarchyDB.EDITABLEATTSID.Int64 = int64(BackRepoEDITABLEATTSid_atBckpTime_newID[uint(spechierarchyDB.EDITABLEATTSID.Int64)])
			spechierarchyDB.EDITABLEATTSID.Valid = true
		}

		// reindexing OBJECT field
		if spechierarchyDB.OBJECTID.Int64 != 0 {
			spechierarchyDB.OBJECTID.Int64 = int64(BackRepoOBJECTid_atBckpTime_newID[uint(spechierarchyDB.OBJECTID.Int64)])
			spechierarchyDB.OBJECTID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoSPECHIERARCHY.db.Model(spechierarchyDB).Updates(*spechierarchyDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoSPECHIERARCHY.ResetReversePointers commits all staged instances of SPECHIERARCHY to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, spechierarchy := range backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYPtr {
		backRepoSPECHIERARCHY.ResetReversePointersInstance(backRepo, idx, spechierarchy)
	}

	return
}

func (backRepoSPECHIERARCHY *BackRepoSPECHIERARCHYStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, spechierarchy *models.SPECHIERARCHY) (Error error) {

	// fetch matching spechierarchyDB
	if spechierarchyDB, ok := backRepoSPECHIERARCHY.Map_SPECHIERARCHYDBID_SPECHIERARCHYDB[idx]; ok {
		_ = spechierarchyDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoSPECHIERARCHYid_atBckpTime_newID map[uint]uint
